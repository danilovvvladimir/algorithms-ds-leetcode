namespace NS111 {
  class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
      this.val = val === undefined ? 0 : val;
      this.left = left === undefined ? null : left;
      this.right = right === undefined ? null : right;
    }
  }

  function minDepth(root: TreeNode | null): number {
    if (root === null) return 0;

    const queue = [root];
    let height = 0;

    while (queue.length) {
      const n = queue.length;
      height++;
      for (let i = 0; i < n; i++) {
        const node = queue.shift()!;

        if (!node.left && !node.right) return height;
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
      }
    }

    return height;
  }
}

// Мы начинаем с проверки наличия корневого узла. Если дерево пустое (root === null), мы сразу возвращаем 0, так как глубина пустого дерева равна 0.
// Если корневой узел не пуст, мы создаем пустую очередь (queue), в которую помещаем корневой узел.
// Также у нас есть переменная height, которая будет хранить текущую глубину дерева.

// Мы начинаем цикл while, который будет продолжаться, пока очередь не станет пустой. Каждая итерация этого цикла соответствует одному уровню дерева.
// Внутри цикла мы сначала получаем текущий размер очереди (n) с помощью const n = queue.length;. Это количество узлов в текущем уровне дерева.
// Затем мы увеличиваем переменную height на 1, так как мы переходим на следующий уровень.
// Затем мы начинаем обходить все узлы текущего уровня с помощью цикла for. На каждой итерации мы извлекаем узел из начала очереди с помощью const node = queue.shift();.
// Для каждого извлеченного узла, мы проверяем, является ли он листовым узлом (не имеет детей). Если это так, мы возвращаем текущее значение height, так как нашли минимальную глубину дерева.
// Если у узла есть левый или правый потомок, мы добавляем их в конец очереди, чтобы обработать их на следующем уровне.

// После завершения внутреннего цикла for, мы переходим к следующей итерации цикла while, где обработка продолжится на следующем уровне дерева.
// Когда очередь станет пустой, это означает, что мы обработали все уровни дерева, и функция вернет вычисленную глубину дерева
